class Lazyloadify{constructor(options={}){this.imageCount=0;this.observer=!1;this.selectorClass=options.selectorClass||'.js-lazyload';this.loadedClass=options.loadedClass||'js-lazyloaded';this.rootElement=options.rootElement||null;this.rootMargin=options.rootMargin||'0px';this.treshold=options.treshold||0}
load(){const images=document.querySelectorAll(this.selectorClass);const config={root:this.rootElement,rootMargin:this.rootMargin,threshold:this.treshold};this.imageCount=images.length;if(!('IntersectionObserver' in window)){this.loadImagesImmediately(images)}else{this.observer=new IntersectionObserver(entries=>{if(this.imageCount===0){this.disconnect()}
for(const entry of entries){if(entry.intersectionRatio>0){this.imageCount--;this.observer.unobserve(entry.target);this.preloadImage(entry.target)}}},config);for(const image of images){if(image.classList.contains(this.loadedClass)){continue}
this.observer.observe(image)}}}
fetchImage(url){return new Promise((resolve,reject)=>{const image=new Image();image.src=url;image.onload=resolve;image.onerror=reject})}
preloadImage(image){const src=image.dataset.src;if(!src){return}
return this.fetchImage(src).then(()=>{this.applyImage(image,src)})}
loadImagesImmediately(images){for(const image of images){this.preloadImage(image)}}
disconnect(){if(!this.observer){return}
this.observer.disconnect()}
applyImage(img,src){img.classList.remove(this.selectorClass);img.classList.add(this.loadedClass);if(img.tagName.toLowerCase()==='img'){img.src=src}else{img.style.backgroundImage='url('+src+')'}}}
export default Lazyloadify